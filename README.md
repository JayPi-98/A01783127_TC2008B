<!-- Improved compatibility of back to top link: See: https://github.com/othneildrew/Best-README-Template/pull/73 -->
<a name="readme-top"></a>
<!--
*** Thanks for checking out the Best-README-Template. If you have a suggestion
*** that would make this better, please fork the repo and create a pull request
*** or simply open an issue with the tag "enhancement".
*** Don't forget to give the project a star!
*** Thanks again! Now go create something AMAZING! :D
-->



<!-- PROJECT SHIELDS -->
<!--
*** I'm using markdown "reference style" links for readability.
*** Reference links are enclosed in brackets [ ] instead of parentheses ( ).
*** See the bottom of this document for the declaration of the reference variables
*** for contributors-url, forks-url, etc. This is an optional, concise syntax you may use.
*** https://www.markdownguide.org/basic-syntax/#reference-style-links
-->

<!--
[![Contributors][contributors-shield]][contributors-url]
[![Forks][forks-shield]][forks-url]
[![Stargazers][stars-shield]][stars-url]
[![Issues][issues-shield]][issues-url]
[![MIT License][license-shield]][license-url]
[![LinkedIn][linkedin-shield]][linkedin-url]
-->



<!-- Repositorio de Tareas -->
<br />
<div align="center">
  <a href="https://github.com/othneildrew/Best-README-Template">
    <img src="images/logo.png" alt="Logo" width="80" height="80">
  </a>

  <h3 align="center">Repositorio de Tareas</h3>

  <p align="center">
    TC2005B - A01783127 - Tecnologico de Monterrey
    <br />
    <!--
    <a href="https://github.com/othneildrew/Best-README-Template"><strong>Explore the docs »</strong></a>
    <br />
    <br />
    <a href="https://github.com/othneildrew/Best-README-Template">View Demo</a>
    ·
    <a href="https://github.com/othneildrew/Best-README-Template/issues">Report Bug</a>
    ·
    <a href="https://github.com/othneildrew/Best-README-Template/issues">Request Feature</a>
    -->
  </p>
</div>



<!-- TABLE OF CONTENTS -->
<details>
  <summary>Tabla de contenidos</summary>
  <ol>
    <li>
      <a href="#about-the-project">Acerca del proyecto</a>
      <ul>
        <li><a href="Reto">Reto</a></li>
      </ul>
    </li>
    <a href="#Contenidos de aprendizaje">Contenidos de aprendizaje</a>
</details>



<!-- ABOUT THE PROJECT -->
## Acerca del proyecto

Para esta clase aprenderemos a utilizar múltiples lenguajes de programación con la intención de poder crear un videojuego. Este mismo tendrá una base de datos que se estará almacenando en un servidor en la nube, por lo que diferentes herramientas deberán ser empleadas para la satisfactoria realización del proyecto. Este repositorio tiene como propósito almacenar las tareas realizadas en la clase de construcción de software y toma de decisiones de manera pública. Esto falicitará el acceso a los documentos y resultará en una mejor organización de los archivos para futuros trabajos.

<p align="right">(<a href="#readme-top">back to top</a>)</p>



### Reto

Simuladores Computacionales

Construir un simulador computacional que reproduzca el comportamiento parcial de un sistema empresarial, económico, social, político, educativo. Este simulador permitirá el análisis de escenarios actuales o futuros para el apoyo en la toma de decisiones hacia la mejora de alguno de los procesos, o componentes del sistema. El simulador tendrá una interfaz gráfica equiparable a un videojuego 2D o 3D.

<p align="right">(<a href="#readme-top">back to top</a>)</p>



<!-- GETTING STARTED -->
## Contenidos de aprendizaje

1. Metodologías ágiles en el desarrollo de software.

1.1 Iteraciones en el desarrollo ágil.

1.2 Actores en el desarrollo ágil.

1.3 Ejemplos de metodologías de desarrollo ágil.

1.4 Proceso completo de desarrollo de software.

1.5 Especificar los requerimientos necesarios para el desarrollo de un sistema de software usando un estándar propietario.

1.6 Desarrolla casos de uso y diagramas de actividad.

1.7 Valorar la importancia de la especificación de requerimientos en un desarrollo orientado al usuario.

 

2. Análisis y diseño del software.

2.1 Design thinking para el desarrollo de software.

2.1.1 El proceso de design thinking.

2.1.2 Especificaciones de usabilidad.

2.1.3 Definición del perfil del usuario (observación, encuestas).

2.1.4 Diseñar personas, ambientes de trabajo y escenarios.

2.1.5 Interfaz, heurísticas y storyboard.

2.2 Uso herramientas para generación automática de código a partir de los modelos.

2.3 Diagramas de UML.

2.3.1 Diagramas secuencias.

2.3.2 Diagramas de interacción.

2.3.3 Diagramas de clases.

2.3.4 Diagramas de estados.

2.3.5 Diagramas de componentes.

2.3.6 Diagramas de objetos.

2.4 Patrones de diseño Modelo-Vista-Controlador.

2.5 Arquitectura cliente-servidor.

2.6 Modelo relacional.

2.6.1 Conceptos del modelo Relacional (PK, FK, grado, cardinalidad, reglas de Integridad).

2.6.2 Mapeo de diagramas de clases a tablas relacionales.

2.6.3 Algebra relacional.

2.6.4 SQL DDL.

2.6.5 SQL DML.

2.6.6 Procedimientos almacenados y triggers.

2.6.7 Transacciones.

2.6.8 Control de concurrencia y recuperación.

 

3. Calidad en el software.

3.1 Generación de casos de prueba (definir qué quiere el usuario probar).

3.2 Pruebas estáticas y manuales.

3.3 Pruebas de caja blanca.

3.4 Pruebas unitarias.

3.5 Pruebas funcionales.

 

4. Despliegue de software.

4.1 Manual de usuario.

4.2 Manual de instalación.

4.3 Software de sistema de control de versiones.

 

5. Desarrollo WEB.

5.1 Desarrollo de interfaz gráfica responsiva (Front-end).

5.1.1 HTML5.

5.1.2 CSS3.

5.1.3 JavaScript.

5.1.4 Marcos de desarrollo y herramientas responsivas (Jquery, Bootstrap, etc.).

5.2 Desarrollo en el servidor (Backend).

5.2.1 Servicios REST.

5.2.2 Lenguaje de alto nivel para sistemas web (java, C#, PHP, javascript, Ruby, etc.).

5.2.3 Marcos de desarrollo y herramientas para servicios REST.

 

6. Sistema transaccional.

6.1 Definición de requerimientos del sistema responsivo usando un estándar propietario.

6.1.1 Definir requerimientos funcionales.

6.1.2 Definición de requerimientos de Información.

6.1.3 Definición de requerimientos no funcionales.

6.2 Diseño de la aplicación web.

6.2.1 Realización de diagrama de clases para satisfacer requerimientos de información.

6.2.2 Creación de la base de datos y generación del modelo relacional.

6.2.3 Generación de datos y reportes usando DML.

6.2.4 Creación del Backend.

6.2.5 Creación del Front End.

6.3 Despliegue y pruebas del sistema.

 

7. Proceso de toma de decisiones.

7.1 Identificación de indicadores de desempeño.

7.2 Reportes que generen estadísticas para mostrar indicadores de desempeño.

7.3 Aplicación de métodos matemáticos (por ejemplo: regresión lineal) para la identificación de patrones en un indicador de desempeño.

7.4 Identificación de interacciones causa-efecto entre los indicadores de desempeño.

7.5 Visualización gráfica de información para la toma de decisiones.

 

8. Proceso de desarrollo de videojuegos.

8.1 Conceptos básicos de videojuegos.

8.2 Tipos de juegos.

8.3 Industria de videojuegos.

8.4 Elementos básicos de un juego 2D o 3D.

8.5 Conceptos de ciencias básicas en el desarrollo de un videojuego 2D o 3D.

8.5.1 Uso de matemáticas en un videojuego 2D o 3D.

8.5.1.1 Cálculo de distancia.

8.5.1.2 Cálculo de ángulos.

8.5.2 Uso de física en un videojuego 2D o 3D.

8.5.2.1 Aplicación de la gravedad.

8.5.2.2 Aplicación de propiedades de rigidez, fricción, volumen, masa a objetos.

8.6 Motores para el desarrollo de videojuegos.

8.6.1 Conocer los motores de juego actuales.

8.6.2 Seleccionar el motor de videojuego para el desarrollo de un videojuego 2D o 3D.

8.7 Interacción humano-computadora en los videojuegos 2D o 3D.

8.7.1 Definición de requerimientos para el videojuego.

8.7.2 Modelación de usuarios.

8.7.3 Definición de escenarios y casos de uso para el videojuego.

8.7.4 Realización de las especificaciones de usabilidad del videojuego.

8.8 Diseño de un videojuego 2D o 3D.

8.8.1 Construcción de los casos de uso de un videojuego.

8.8.2 Construcción de los diagramas de clase para un videojuego.

8.9 Desarrollo e implementación de un videojuego 2D o 3D.

8.9.1 Creación de los elementos básicos de la interfaz gráfica.

8.9.2 Manejo de la distribución de los elementos de la interfaz gráfica.

8.9.3 Detección y manejo de colisiones.

8.9.4 Manejo de interacción con el usuario.

8.9.5 Manejo de hilos de ejecución.

8.9.6 Uso de música y efectos de sonido.

8.9.7 Manejo de retroalimentación al usuario a través de hápticos.

8.10 Derechos de autor.

8.10.1 Derechos de autor en imágenes y audio.

8.10.2 Licencias de software.

